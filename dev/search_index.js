var documenterSearchIndex = {"docs":
[{"location":"api/general/#General-APIs","page":"General APIs","title":"General APIs","text":"","category":"section"},{"location":"api/general/#CellularAutomata.CellularAutomaton","page":"General APIs","title":"CellularAutomata.CellularAutomaton","text":"CellularAutomaton(rule::AbstractODRule, initial_conditions, generations)\nCellularAutomaton(rule::AbstractTDRule, initial_conditions, generations)\n\nConstructs the evolution of a cellular automaton based on a specified rule, initial conditions, and the number of generations to simulate. This function supports both one-dimensional (OD) and two-dimensional (TD) cellular automata, determined by the type of rule provided.\n\nArguments\n\nrule: An instance of AbstractODRule for one-dimensional cellular automata or AbstractTDRule for two-dimensional cellular automata. Defines the evolution rule for the cellular automaton.\ninitial_conditions: An array (for OD) or a matrix (for TD) representing the initial state of the cellular automaton.\ngenerations: The number of generations (or time steps) for which the automaton should be evolved.\n\nUsage\n\nFor a one-dimensional cellular automaton:\n\nrule = DCA(30)  # Define or instantiate a one-dimensional rule\ninitial_conditions = [0, 1, 0, 1, 1, 0, 1]  # Initial state array\ngenerations = 50  # Number of generations to simulate\nautomaton_od = CellularAutomaton(rule, initial_conditions, generations)\n\nFor a two-dimensional cellular automaton:\n\nrule = Life(((3,), (2, 3)))  # Define or instantiate a two-dimensional rule\ninitial_conditions = [  # Initial state matrix\n    [0, 1, 0],\n    [1, 0, 1],\n    [0, 1, 0],\n]\ngenerations = 50  # Number of generations to simulate\nautomaton_td = CellularAutomaton(rule, initial_conditions, generations)\n\nThis function constructs a CellularAutomaton instance that encapsulates the entire evolution history of the cellular automaton, according to the provided rule and initial conditions over the specified number of generations. The exact nature of the evolution—whether it is for a one-dimensional or two-dimensional automaton—depends on the type of rule supplied.\n\nYou can access the evolution by calling the evolution field of CellularAutomaton\n\nautomaton_td.evolution\n\nNotes\n\nThe rule parameter determines the dimensionality of the cellular automaton. Ensure that your initial_conditions and rule are compatible in terms of dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/twodim/#Two-dimensional-Cellular-Automata","page":"Two Dimensial CA","title":"Two dimensional Cellular Automata","text":"","category":"section"},{"location":"api/twodim/#Life-Like-Cellular-Automata","page":"Two Dimensial CA","title":"Life-Like Cellular Automata","text":"","category":"section"},{"location":"api/twodim/#CellularAutomata.Life","page":"Two Dimensial CA","title":"CellularAutomata.Life","text":"Life(life_description; radius=1)\n\nCreate a Life object to simulate a cellular automaton based on a variation of the Conway's Game of Life, using custom rules for cell birth and survival. The rules are defined using the Golly notation.\n\nArguments\n\nlife_description: A tuple of two tuples ((b, s)) specifying the birth (b) and survival (s) rules.\nb: A tuple containing the numbers of neighbouring cells that cause a dead cell to become alive in the next generation.\ns: A tuple containing the numbers of neighbouring cells that allow a live cell to remain alive in the next generation.\nradius (optional): The radius of the neighborhood considered for determining cell fate. Defaults to 1.\n\nUsage\n\nlife = Life(((3,), (2, 3)); radius=1)  # Initializes Life\n\nAfter instantiation, the Life object can be used to evolve a given starting array representing the initial state of the cellular automaton:\n\n# Initialize Life with custom rules: birth if 3 neighbors, survive if 2 or 3 neighbors\nlife = Life(((3,), (2, 3)); radius=1)\n\n# Example starting state: a 5x5 grid with a \"glider\" pattern\nstarting_array = zeros(Int, 5, 5)\nstarting_array[2, 3] = 1\nstarting_array[3, 4] = 1\nstarting_array[4, 2:4] = 1\n\n# Compute the next generation\nnext_generation = life(starting_array)\n\n\n\n\n\n","category":"type"},{"location":"onedim/onedimensionca/#One-Dimensional-Cellular-Automata","page":"One dimensional CA","title":"One Dimensional Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/#Elementary-Cellular-Automata","page":"One dimensional CA","title":"Elementary Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Elementary Cellular Automata (ECA) have a radius of one and can be in only two possible states. Here we show a couple of examples:","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 18","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 2\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(Bool, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 18\n\nca = CellularAutomaton(DCA(rule), starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 30","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"states = 2\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(Bool, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 30\n\nca = CellularAutomaton(DCA(rule), starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/#Multiple-States-Cellular-Automata","page":"One dimensional CA","title":"Multiple States Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"General Cellular Automata have the same rule of ECA but they can have a radius larger than unity and/or a number of states greater than two. Here are provided examples for every possible permutation, starting with a Cellular Automaton with 3 states.","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 7110222193934","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 3\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 2\n\nrule = 7110222193934 \n\nca = CellularAutomaton(DCA(rule,states=states,radius=radius), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false,\n    size=(ncells*10, generations*10))","category":"page"},{"location":"onedim/onedimensionca/#Larger-Radius-Cellular-Automata","page":"One dimensional CA","title":"Larger Radius Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"The following examples shows a Cellular Automaton with radius=2, with two only possible states:","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 1388968789","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 2\nradius = 2\ngenerations = 30\nncells = 111\nstarting_val = zeros(ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 1388968789 \n\nca = CellularAutomaton(DCA(rule,states=states,radius=radius), \n                           starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false,\n    size=(ncells*10, generations*10))","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"And finally, three states with a radius equal to two:","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 914752986721674989234787899872473589234512347899","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"states = 3\nradius = 2\ngenerations = 30\nncells = 111\nstarting_val = zeros(ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 2\n\nrule = 914752986721674989234787899872473589234512347899 \n\nca = CellularAutomaton(DCA(rule,states=states,radius=radius), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false,\n    size=(ncells*10, generations*10))","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"It is also possible to specify asymmetric neighborhoods, giving a tuple to the kwarg detailing the number of neighbors to considerate at the left and right of the cell: Rule 1235","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"states = 2\nradius = (2,1)\ngenerations = 30\nncells = 111\nstarting_val = zeros(ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 1235 \n\nca = CellularAutomaton(DCA(rule,states=states,radius=radius), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false,\n    size=(ncells*10, generations*10))","category":"page"},{"location":"onedim/onedimensionca/#Totalistic-Cellular-Automata","page":"One dimensional CA","title":"Totalistic Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Totalistic Cellular Automata takes the sum of the neighborhood to calculate the value of the next step.","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 1635","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\nstates = 3\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(Integer, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 1635\n\nca = CellularAutomaton(DCA(rule, states=states), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 107398","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"states = 4\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(Integer, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 107398\n\nca = CellularAutomaton(DCA(rule, states=states), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Here are some results for a bigger radius, using a radius of 2 as an example.","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 53","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"states = 2\nradius = 2\ngenerations = 50\nncells = 111\nstarting_val = zeros(Integer, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 53\n\nca = CellularAutomaton(DCA(rule, radius=radius), \n                           starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/#Continuous-Cellular-Automata","page":"One dimensional CA","title":"Continuous Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Continuous Cellular Automata work in the same way as the totalistic but with real values. The examples are taken from the already mentioned book NKS.","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 0.025","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\ngenerations = 50\nncells = 111\nstarting_val = zeros(Float64, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1.0\n\nrule = 0.025\n\nca = CellularAutomaton(CCA(rule), starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 0.2","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"radius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(Float64, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1.0\n\nrule = 0.2\n\nca = CellularAutomaton(CCA(rule, radius=radius), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"twodim/twodimensionca/#Two-Dimensional-Cellular-Automata","page":"Two dimensional CA","title":"Two Dimensional Cellular Automata","text":"","category":"section"},{"location":"twodim/twodimensionca/#Game-of-Life","page":"Two dimensional CA","title":"Game of Life","text":"","category":"section"},{"location":"twodim/twodimensionca/","page":"Two dimensional CA","title":"Two dimensional CA","text":"This package can also reproduce Conway's Game of Life, and any variation based on it. The Life() function takes in a tuple containing the number of neighbors that will gave birth to a new cell, or that will make an existing cell survive. (For example in the Conways's Life the tuple (3, (2,3)) indicates having 3 live neighbors will give birth to an otherwise dead cell, and having either 2 or 3 lie neighbors will make an alive cell continue living.) The implementation follows the Golly notation.","category":"page"},{"location":"twodim/twodimensionca/","page":"Two dimensional CA","title":"Two dimensional CA","text":"This script reproduces the famous glider:","category":"page"},{"location":"twodim/twodimensionca/","page":"Two dimensional CA","title":"Two dimensional CA","text":"using CellularAutomata, Plots\n\nglider = [[0, 0, 1, 0, 0] [0, 0, 0, 1, 0] [0, 1, 1, 1, 0]]\n\nspace = zeros(Bool, 30, 30)\ninsert = 1\nspace[insert:insert+size(glider, 1)-1, insert:insert+size(glider, 2)-1] = glider\ngens = 100\nspace_gliding = CellularAutomaton(Life((3, (2,3))), space, gens)\n\nanim = @animate for i = 1:gens\n    heatmap(space_gliding.evolution[:,:,i], \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    size=(1080,1080),\n    axis=false,\n    ticks=false)\nend\n \ngif(anim, \"glider.gif\", fps = 15)","category":"page"},{"location":"api/onedim/#One-dimensional-Cellular-Automata","page":"One Dimensional CA","title":"One dimensional Cellular Automata","text":"","category":"section"},{"location":"api/onedim/#Discrete-Cellular-Automata","page":"One Dimensional CA","title":"Discrete Cellular Automata","text":"","category":"section"},{"location":"api/onedim/#CellularAutomata.DCA","page":"One Dimensional CA","title":"CellularAutomata.DCA","text":"DCA(rule; states=2, radius=1)\n\nCreates a DCA object given a specific rule. It automatically computes the ruleset for the provided rule, number of states, and radius.\n\nArguments\n\nrule: The rule identifier used for the cellular automaton's evolution.\nstates (optional): The number of possible states for each cell. Defaults to 2.\nradius (optional): The neighborhood radius around each cell considered during the evolution. Defaults to 1.\n\nUsage\n\ndca = DCA(30; states=2, radius=1)  # Creates a DCA with rule 30, 2 states, and radius 1.\n\nOnce instantiated, the DCA object can evolve a given starting array of cell states through its callable interface:\n\ndca = DCA(110; states=2, radius=1)  # Initialize with rule 110, 2 states, and a radius of 1\nstarting_array = [0, 1, 0, 1, 1, 0]  # Initial state\nnext_generation = dca(starting_array)  # Evolve to the next generation\n\n\n\n\n\n","category":"type"},{"location":"api/onedim/#CellularAutomata.TCA","page":"One Dimensional CA","title":"CellularAutomata.TCA","text":"TCA(code; states=2, radius=1)\n\nConstructs a Totalistic Cellular Automaton (TCA) with a specified code, number of states, and neighborhood radius. It automatically computes the codeset for the provided code and configuration, which is used for the automaton's evolution.\n\nArguments\n\ncode: An integer or string representing the rule code for the automaton's evolution.\nstates (optional): The number of possible states for each cell. Defaults to 2.\nradius (optional): The neighborhood radius around each cell considered during the evolution. Defaults to 1.\n\nUsage\n\ntca = TCA(30; states=2, radius=1)  # Creates a TCA with rule code 30, 2 states, and radius 1.\n\nAfter instantiation, the TCA object can be used to evolve a given starting array of cell states:\n\n# Initialize TCA with a specific code, default states, and radius\ntca = TCA(102; states=3, radius=1)\n\n# Example starting state: a 1D array of cells\nstarting_array = [0, 2, 1, 0, 1, 2]\n\n# Compute the next generation\nnext_generation = tca(starting_array)\n\n\n\n\n\n","category":"type"},{"location":"api/onedim/#Continuous-Cellular-Automata","page":"One Dimensional CA","title":"Continuous Cellular Automata","text":"","category":"section"},{"location":"api/onedim/#CellularAutomata.CCA","page":"One Dimensional CA","title":"CellularAutomata.CCA","text":"CCA(rule; radius=1)\n\nCreate a Continuous Cellular Automaton (CCA) object.\n\nArguments\n\nrule: A numeric code defining the evolution rule for the cellular automaton.\nradius (optional): The radius of the neighborhood around each cell considered for its update at each step. Defaults to 1.\n\nReturns\n\nCCA: A CCA object initialized with the given rule and radius.\n\nExamples\n\ncca = CCA(0.5)\n\nOnce created, the CCA object can be used to evolve a given starting array of cell states:\n\ncca = CCA(0.45; radius=1)  # Initialize with rule 0.45 and default radius\nstarting_array = [0, 1, 0, 1, 0.5, 1]  # Initial state\nnext_generation = cca(starting_array)  # Evolve to next generation\n\nThe evolution is determined by the rule applied to the sum of the neighborhood states, normalized by their count, for each cell in the array.\n\n\n\n\n\n","category":"type"},{"location":"#CellularAutomata.jl","page":"CellularAutomata.jl","title":"CellularAutomata.jl","text":"","category":"section"},{"location":"","page":"CellularAutomata.jl","title":"CellularAutomata.jl","text":"This package is meant to be a complete Open source reference for everything regarding Cellular Automata. In it you will find ways to create one and two dimensional Cellular Automata models and functions  to analyze them","category":"page"},{"location":"#General-usage","page":"CellularAutomata.jl","title":"General usage","text":"","category":"section"},{"location":"","page":"CellularAutomata.jl","title":"CellularAutomata.jl","text":"The main function is given by CellularAutomaton where rule is a function returning the next state of the Cellular Automata. ","category":"page"},{"location":"#Contributions","page":"CellularAutomata.jl","title":"Contributions","text":"","category":"section"},{"location":"","page":"CellularAutomata.jl","title":"CellularAutomata.jl","text":"Contributions are more than welcomed! I do not have too much bandwidth for this package at the moment, but I will try to take care of any contributions should they come.","category":"page"}]
}
